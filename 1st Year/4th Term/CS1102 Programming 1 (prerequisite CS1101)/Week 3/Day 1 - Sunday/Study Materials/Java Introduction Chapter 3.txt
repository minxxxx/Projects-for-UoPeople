3. Default Methods
In order to add the stream method (or any others) to the core Collections API, Java needed another new feature, Default methods (also known as Defender Methods or Virtual Extension methods). This way they could add new methods to the List interface for example without breaking all the existing implementations (backwards compatibility).

Default methods can be added to any interface. Like the name implies, any class that implements the interface but does not override the method will get the default implementation.

For example, the stream method in the Collection interface is defined something like the following:

1 default public Stream stream() {
2 	return StreamSupport.stream(spliterator());
3 }

See the Java docs for more on Spliterators.

You can always override a default method if you need different behavior.

3.1 Default and Functional
An interface can have one or more default methods and still be functional.

For example, take a look at the Iterable interface:

 1 @FunctionalInterface
 2 public interface Iterable {
 3 	Iterator iterator();
 4 	default void forEach(Consumer<? super T> action) {
 5 		Objects.requireNonNull(action);
 6 		for (T t : this) {
 7 			action.accept(t);
 8 		}
 9 	}
10 }

It has both the iterator() method and the forEach method.

3.2 Multiple Defaults
In the unlikely case that your class implements two or more interfaces that define the same default method, Java will throw a compilation error. You will need to override the method and choose from one of the methods. For example:

 1 interface Foo {
 2 	default void talk() {
 3 		out.println("Foo!");
 4 	}
 5 }
 6 interface Bar {
 7 	default void talk() {
 8 		out.println("Bar!");
 9 	}
10 }
11 class FooBar implements Foo, Bar {
12 	@Override
13 	void talk() { Foo.super.talk(); }			
14 }

In the above code, talk is overridden and calls Foo’s talk method. This is similar to the way you refer to a super class in pre-Java-8.

3.3 Static Methods on Interface
Although not strictly related to default methods, the ability to add static methods to interfaces is a similar change to the Java language.

For example, there are many static methods on the new Stream interface. This makes “helper” methods easier to find since they can be located directly on the interface, instead of a different class such as StreamUtil or Streams.

Here’s an example in the new Stream interface:

1 public static<T> Stream<T> of(T... values) {
2     return Arrays.stream(values);
3 }

The above method creates a new stream based on the given values.